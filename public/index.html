<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Terminal</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: Arial, sans-serif;
            background: #1e1e1e;
            color: #d4d4d4;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        .header {
            background: #2d2d2d;
            border-bottom: 1px solid #3e3e3e;
            padding: 10px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 50px;
        }
        .header h1 {
            font-size: 18px;
            color: #4fc1ff;
        }
        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .btn {
            background: #3e3e3e;
            border: 1px solid #555;
            color: #d4d4d4;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .btn:hover { background: #4e4e4e; }
        .btn-primary {
            background: #007acc;
            border-color: #005a9e;
        }
        .btn-primary:hover { background: #0086e6; }
        .tabs-container {
            background: #252526;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            align-items: center;
            padding: 0 10px;
            min-height: 35px;
            overflow-x: auto;
        }
        .tabs-container.hidden {
            display: none;
        }
        .tab {
            background: transparent;
            border: none;
            color: #969696;
            padding: 8px 15px;
            cursor: pointer;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            border-bottom: 2px solid transparent;
            white-space: nowrap;
        }
        .tab:hover { background: #2d2d2d; color: #d4d4d4; }
        .tab.active {
            color: #ffffff;
            border-bottom-color: #007acc;
            background: #1e1e1e;
        }
        .tab-close {
            opacity: 0;
            font-size: 14px;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 3px;
        }
        .tab:hover .tab-close { opacity: 1; }
        .tab-close:hover { background: #4e4e4e; }

        /* 平铺模式容器 */
        .tile-container {
            flex: 1;
            display: none;
            gap: 2px;
            padding: 2px;
            overflow: hidden;
        }
        .tile-container.visible {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            grid-template-rows: repeat(2, 1fr);
        }
        .tile-container.visible .tile-single {
            grid-column: 1 / -1;
            grid-row: 1 / -1;
        }
        .tile-container.visible .tile-two {
            grid-column: span 1;
            grid-row: span 1;
        }

        .terminal-wrapper {
            background: #1e1e1e;
            border: 1px solid #3e3e3e;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }
        .terminal-wrapper .terminal-header {
            background: #2d2d2d;
            padding: 4px 8px;
            font-size: 11px;
            color: #969696;
            border-bottom: 1px solid #3e3e3e;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .terminal-wrapper .terminal-content {
            flex: 1;
            padding: 5px;
            min-height: 0;
        }
        .terminal-wrapper .terminal-content .xterm {
            height: 100%;
        }

        .terminal-container {
            flex: 1;
            background: #1e1e1e;
            padding: 10px;
            overflow: hidden;
        }
        .terminal-container.hidden {
            display: none;
        }
        #terminal { width: 100%; height: 100%; }
        .status-bar {
            background: #007acc;
            padding: 3px 10px;
            font-size: 12px;
            color: white;
            display: flex;
            justify-content: space-between;
        }
    </style>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css" />
</head>
<body>
    <div class="header">
        <h1>Web Terminal</h1>
        <div class="header-controls">
            <span id="connectionStatus">Connected</span>
            <select id="layoutMode" class="btn" onchange="switchLayoutMode(this.value)">
                <option value="tab">Tab 模式</option>
                <option value="tile">平铺模式</option>
            </select>
            <button class="btn btn-primary" onclick="createNewTerminal()">+ New Terminal</button>
        </div>
    </div>
    <div class="tabs-container" id="tabsContainer"></div>
    <div class="terminal-container" id="tabModeContainer">
        <div id="terminal"></div>
    </div>
    <div class="tile-container" id="tileModeContainer"></div>
    <div class="status-bar">
        <span id="terminalInfo">Ready</span>
        <span id="dimensions">80x24</span>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const socket = io();
        let currentTermId = null;
        let terminal = null;
        let fitAddon = null;
        // 存储所有终端的完整历史
        const terminalHistories = {};
        // 当前布局模式
        let layoutMode = 'tab';
        // 存储所有终端实例（平铺模式需要）
        const terminals = {};
        // 存储所有终端ID
        let terminalIds = [];

        function initTerminal() {
            terminal = new Terminal({
                cursorBlink: true,
                fontSize: 14,
                fontFamily: 'monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#d4d4d4',
                    cursor: '#d4d4d4'
                }
            });
            fitAddon = new FitAddon.FitAddon();
            terminal.loadAddon(fitAddon);
            terminal.open(document.getElementById('terminal'));
            fitAddon.fit();

            terminal.onData((data) => {
                if (currentTermId) {
                    socket.emit('terminal-input', { termId: currentTermId, input: data });
                }
            });

            setTimeout(() => {
                fitAddon.fit();
                const { cols, rows } = terminal;
                document.getElementById('dimensions').textContent = cols + 'x' + rows;
                if (currentTermId) {
                    socket.emit('terminal-resize', { termId: currentTermId, cols, rows });
                    // 写入当前终端的历史记录
                    if (terminalHistories[currentTermId]) {
                        terminal.write(terminalHistories[currentTermId]);
                    }
                }
            }, 100);
        }

        // 切换布局模式
        function switchLayoutMode(mode) {
            layoutMode = mode;
            const tabsContainer = document.getElementById('tabsContainer');
            const tabModeContainer = document.getElementById('tabModeContainer');
            const tileModeContainer = document.getElementById('tileModeContainer');

            if (mode === 'tile') {
                tabsContainer.classList.add('hidden');
                tabModeContainer.classList.add('hidden');
                tileModeContainer.classList.add('visible');
                renderTiles();
            } else {
                tabsContainer.classList.remove('hidden');
                tabModeContainer.classList.remove('hidden');
                tileModeContainer.classList.remove('visible');
                // 切换回tab模式时，确保当前终端有实例
                if (!terminal && currentTermId) {
                    initTerminal();
                    if (pendingHistory[currentTermId]) {
                        terminal.write(pendingHistory[currentTermId]);
                        delete pendingHistory[currentTermId];
                    }
                }
            }
        }

        // 创建单个平铺终端实例
        function createTileTerminal(termId) {
            const term = new Terminal({
                cursorBlink: true,
                fontSize: 12,
                fontFamily: 'monospace',
                theme: {
                    background: '#1e1e1e',
                    foreground: '#d4d4d4',
                    cursor: '#d4d4d4'
                }
            });
            const tileFitAddon = new FitAddon.FitAddon();
            term.loadAddon(tileFitAddon);

            // 创建容器
            const wrapper = document.createElement('div');
            wrapper.className = 'terminal-wrapper';
            wrapper.id = 'wrapper-' + termId;
            if (terminalIds.length === 1) {
                wrapper.classList.add('tile-single');
            } else if (terminalIds.length === 2) {
                wrapper.classList.add('tile-two');
            }

            const header = document.createElement('div');
            header.className = 'terminal-header';
            header.innerHTML = `<span>Term ${termId.split('_')[1]}</span><span style="cursor:pointer;opacity:0.7;padding:2px 6px;" onclick="closeTerminal('${termId}', event)">✕</span>`;

            const content = document.createElement('div');
            content.className = 'terminal-content';

            wrapper.appendChild(header);
            wrapper.appendChild(content);
            document.getElementById('tileModeContainer').appendChild(wrapper);

            term.open(content);
            tileFitAddon.fit();

            // 存储实例和fitAddon
            terminals[termId] = { term, fitAddon: tileFitAddon, wrapper };

            // 设置输入处理
            term.onData((data) => {
                socket.emit('terminal-input', { termId, input: data });
            });

            // 延迟调整大小
            setTimeout(() => {
                tileFitAddon.fit();
                const { cols, rows } = term;
                socket.emit('terminal-resize', { termId, cols, rows });
                // 写入历史记录
                if (terminalHistories[termId]) {
                    term.write(terminalHistories[termId]);
                }
            }, 100);

            return term;
        }

        // 渲染平铺模式
        function renderTiles() {
            const container = document.getElementById('tileModeContainer');
            container.innerHTML = '';

            terminalIds.forEach(termId => {
                if (!terminals[termId]) {
                    createTileTerminal(termId);
                } else {
                    // 更新wrapper类名以适应终端数量
                    const wrapper = terminals[termId].wrapper;
                    wrapper.className = 'terminal-wrapper';
                    if (terminalIds.length === 1) {
                        wrapper.classList.add('tile-single');
                    } else if (terminalIds.length === 2) {
                        wrapper.classList.add('tile-two');
                    }
                    container.appendChild(wrapper);
                    // 重新fit
                    setTimeout(() => {
                        terminals[termId].fitAddon.fit();
                    }, 50);
                }
            });
        }

        socket.on('connect', () => {
            document.getElementById('connectionStatus').textContent = 'Connected';
            document.getElementById('connectionStatus').style.color = '#4fc1ff';
        });

        socket.on('disconnect', () => {
            document.getElementById('connectionStatus').textContent = 'Disconnected';
            document.getElementById('connectionStatus').style.color = '#f14c4c';
        });

        socket.on('terminal-created', (data) => {
            const { termId, isInitial, isRestored } = data;
            if (!isRestored) {
                // 新创建的终端，添加到列表并创建tab
                if (terminalIds.indexOf(termId) === -1) {
                    terminalIds.push(termId);
                }
                createTab(termId);
                // 切换到新终端
                switchTab(termId);
                if (!terminal) initTerminal();

                // 如果是平铺模式，重新渲染
                if (layoutMode === 'tile') {
                    renderTiles();
                }
            }
        });

        socket.on('terminals-restored', (data) => {
            const { termIds, active } = data;
            terminalIds = termIds;
            // 清空现有tabs
            document.getElementById('tabsContainer').innerHTML = '';
            // 创建所有tab
            termIds.forEach(termId => {
                createTab(termId);
            });
            if (!terminal) initTerminal();
            switchTab(active);

            // 如果是平铺模式，重新渲染
            if (layoutMode === 'tile') {
                renderTiles();
            }
        });

        socket.on('terminal-output', (data) => {
            const { termId, data: output } = data;
            // 保存到历史记录
            if (!terminalHistories[termId]) {
                terminalHistories[termId] = '';
            }
            terminalHistories[termId] += output;

            if (layoutMode === 'tile') {
                // 平铺模式：发送到对应终端
                if (terminals[termId]) {
                    terminals[termId].term.write(output);
                }
            } else {
                // Tab模式：只发送到当前活动终端
                if (termId === currentTermId && terminal) {
                    terminal.write(output);
                }
            }
        });

        socket.on('terminal-history', (data) => {
            const { termId, history } = data;
            if (history) {
                // 保存完整历史
                terminalHistories[termId] = history;

                if (layoutMode === 'tile') {
                    // 平铺模式
                    if (terminals[termId]) {
                        terminals[termId].term.write(history);
                    }
                } else {
                    // Tab模式：只显示当前终端的历史
                    if (terminal && termId === currentTermId) {
                        terminal.write(history);
                    }
                }
            }
        });

        socket.on('terminal-closed', (data) => {
            const { termId } = data;
            removeTab(termId);
            // 删除平铺模式的终端实例
            if (terminals[termId]) {
                delete terminals[termId];
            }
            // 删除历史记录
            if (terminalHistories[termId]) {
                delete terminalHistories[termId];
            }
            // 更新terminalIds列表
            terminalIds = terminalIds.filter(id => id !== termId);
            // 如果是平铺模式，重新渲染
            if (layoutMode === 'tile') {
                renderTiles();
            }
        });

        function createTab(termId) {
            const container = document.getElementById('tabsContainer');
            const tab = document.createElement('button');
            tab.className = 'tab';
            tab.id = 'tab-' + termId;
            tab.innerHTML = '<span>Term ' + termId.split('_')[1] + '</span><span class="tab-close" onclick="closeTerminal(\'' + termId + '\', event)">✕</span>';
            tab.onclick = () => switchTab(termId);
            container.appendChild(tab);

            const tabs = container.querySelectorAll('.tab');
            tabs.forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            currentTermId = termId;
        }

        function switchTab(termId) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById('tab-' + termId).classList.add('active');
            currentTermId = termId;
            socket.emit('switch-terminal', { termId });
            // 清空终端并写入该终端的历史
            if (terminal) {
                terminal.clear();
                if (terminalHistories[termId]) {
                    terminal.write(terminalHistories[termId]);
                }
            }
        }

        function createNewTerminal() {
            socket.emit('create-terminal', {});
        }

        function closeTerminal(termId, event) {
            event.stopPropagation();
            socket.emit('close-terminal', { termId });
            // 不在这里调用removeTab，等待服务器的terminal-closed事件
        }

        function removeTab(termId) {
            const tab = document.getElementById('tab-' + termId);
            if (tab) tab.remove();

            if (currentTermId === termId) {
                const remaining = document.querySelectorAll('.tab');
                if (remaining.length > 0) {
                    const newTermId = remaining[0].id.replace('tab-', '');
                    switchTab(newTermId);
                } else {
                    currentTermId = null;
                    if (terminal) terminal.clear();
                }
            }
        }

        window.addEventListener('resize', () => {
            if (fitAddon) {
                fitAddon.fit();
                const { cols, rows } = terminal;
                document.getElementById('dimensions').textContent = cols + 'x' + rows;
                if (currentTermId) {
                    socket.emit('terminal-resize', { termId: currentTermId, cols, rows });
                }
            }
        });
    </script>
</body>
</html>
